### 解题思路

我总结了解决背包问题的五个步骤，分享给大家
1. 列出问题中变量
2. 写出所求的问题
3. 分析出和第2步里边问题直接相关的变量，作为dp数组的最后一维
4. 把除了上一步之外的其它参数按容易理解的方式排列，构造dp数组
5. 遍历参数逐步计算出最后结果

> 内层循环的方向：可复用时从小到大，不可复用时从大到小循环

以本题为例来说明上面的5个步骤
1. 问题涉及到的变量：项目数(包含需要的人数和收益两个子变量)、人数、收益

> a: 项目数
>
>> a1: 项目需要人数
>> a2: 项目的收益
>
> b: 人数
> c: 收益

2. 所求问题：满足最小收益的**方案数**
3. 从第二步可以看到，和所求问题直接相关的是*收益*，所以dp数组的最后一维就是c(收益)
4. 剩下的就是两个变量是a(项目数)和b(人数)，单纯从理解来说谁在前面都行，不过因为这道题里边a(项目)这个参数比较复杂，里边还包含a1(项目需要人数)和a2(项目收益)两个子变量，而且a1(项目需要人数)这个参数和参数b(人数)还有关系，所以要把a(项目数)放到第一维，这样dp数组就构造出来了

* java

```java
dp[项目数][人数][收益] = 方案数
```

> 注意：实际操作中可以通过去掉dp数组的第一个维度，从而节省内存，这是因为状态转移过程里边只会用到前一轮的结果，而且遍历的顺序是固定的。直接用

* java

```java
dp[人数][收益] = 方案数
```

5. 通过遍历求解就行了，思路是：

> 先设置起始条件，就是：一共有0个项目，0个人，0收益的方案数是1
> 然后用起始条件一点一点做遍历就行了，比如：
>
>> 有一个项目需要2个人能收益100元(假设总人数大于2)，现在2个人收益100元的项目就有1种方案了
>> 也就是dp[2][100] += dp[2 - 2][100 - 100]
>
> 依次迭代下去就出来最后结果了

注意：dp里边的人数是指正好用多少个人，而总方案是只要人够用就行，所以最后要把符合收益的所有人数的结果加起来

另外，模运算(%)是个耗时的元算，不过这个问题里边每次都是两个小于MOD的数相加之后再对MOD取模，这就等价于相加之后如果比MOD大，然后减一个MOD就行

### 代码

* java

```java
class Solution {
    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        int MOD = 1_000_000_000 + 7;

        int N = group.length;

        int[][] dp = new int[n + 1][minProfit + 1];
        dp[0][0] = 1;

        for (int i = 0; i < N; i++) {
            int g = group[i];
            int p = profit[i];
            for (int j = n; j >= g; j--) {
                for (int k = minProfit; k >= 0; k--) {
                    dp[j][k] += dp[j - g][Math.max(k - p, 0)];
                    if (dp[j][k] > MOD) {
                        dp[j][k] -= MOD;
                    }
                }
            }
        }

        int sum = 0;
        for (int i = 0; i <= n; i++) {
            sum += dp[i][minProfit];
            if (sum > MOD) {
                sum -= MOD;
            }
        }

        return sum;
    }
}
```

